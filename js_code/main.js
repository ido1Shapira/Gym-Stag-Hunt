//
// Author: Ido Shapira
// date: 15/05/2022
//
var ctx = null;
var canvas = null;
var gameMap = [
	0, 0, 0, 0, 0, 0, 0,
	0, 1, 1, 1, 1, 1, 0,
	0, 1, 1, 1, 1, 1, 0,
	0, 1, 1, 1, 1, 1, 0,
	0, 1, 1, 1, 1, 1, 0,
	0, 1, 1, 1, 1, 1, 0,
	0, 0, 0, 0, 0, 0, 0,
];
var tileW = 50, tileH = 50;
var mapW = 7, mapH = 7;

var finishFlag = false;
var counter_step = 0;
const steps_per_game = 10; // How many episodes (time steps) occur during a single game of Stag Hunt before entity positions are reset and the game is considered done.

// reward function:
const stag_reward = 5; // Reinforcement reward for when agents catch the stag by occupying the same cell as it at the same time. Expected to be positive.
const forage_reward = 1; //Reinforcement reward for harvesting a plant. Expected to be positive.
const mauling_punishment = -5; //Reinforcement reward (or, rather, punishment) for getting mauled by a stag. Expected to be negative.

// time:
var currentSecond = 0, frameCount = 0, framesLastSecond = 0, lastFrameTime = 0;

// initialize:
                    // tileFrom , tileTo, timeMoved, dimensions, position, delayMove, icon
var human_player = new Player([5,1], [5,1], 0, [30,30], [260,60], 500, "red_agent.png");
initializeFirebase();
var computer_player = new Player([1,1], [1,1], 0, [30,30], [60,60], 500, "blue_agent.png");
var computer_controller = null;
firebase.database().ref("chosen-controller").once('value',
    (snap) => {
        selectedBehavior = snap.val();		
        computer_controller = new PlayerController(computer_player, selectedBehavior);

		var type = computer_controller.getType();
        // Generate a reference to a new location and add some data using push()
        var newPostRef = firebase.database().ref("all-games").push({
            behavior: type
        });
        // Get the unique ID generated by push() by accessing its key
        postID = newPostRef.key;
        // console.log("postID: "+postID);
    });

var stag = new Player([3,3], [3,3], 0, [30,30], [160,160], 500, "stag.png");
stag_controller = new StagController(stag, "random");

var shrubs = [];
for(var i=0; i<2; i++) {
	var new_shrub = new Shrub([15,15], "plant_fruit.png", gameMap, tileW, tileH, mapW, mapH);
	shrubs.push(new_shrub);
	if(i==0) {
		new_shrub.set_tile(computer_player.tileFrom, human_player.tileFrom, stag.tileFrom, shrubs[i].tile);
	}
	else {
		new_shrub.set_tile(computer_player.tileFrom, human_player.tileFrom, stag.tileFrom, shrubs[0].tile);
	}
	
}

function toIndex(x, y)
{
	return((y * mapW) + x);
}

function zeros(dimensions) { // dimensions = [r,c] 
    var array = [];
    for (var i = 0; i < dimensions[0]; ++i) {
        array.push(dimensions.length == 1 ? 0 : zeros(dimensions.slice(1)));
    }
    return array;
}

var prev_state = [[], zeros([mapW, mapH]), zeros([mapW, mapH]), zeros([mapW, mapH]), []];
prev_state[1][human_player.tileFrom[1]][human_player.tileFrom[0]] = 1;
prev_state[2][computer_player.tileFrom[1]][computer_player.tileFrom[0]] = 1;

function getBoardState() {
	var state = [
			[], // the board
			[], // human trace
			[], // computer trace
			[], // stag trace
			zeros([mapW, mapH]) // all Shrubs
			];
	
	// game map
	var board = gameMap.slice();
	while(board.length) state[0].push(board.splice(0,mapW)); // reshape board

	//human trace
	for(var i=0; i<prev_state[1].length; i++) {
		state[1].push(prev_state[1][i].map(x => Number((x * 0.9).toFixed(2))));
	}
	state[1][human_player.tileFrom[1]][human_player.tileFrom[0]] = 1;
	//computer trace 
	for(var i=0; i<prev_state[2].length; i++) {
		state[2].push(prev_state[2][i].map(x => Number((x * 0.9).toFixed(2))));
	}
	state[2][computer_player.tileFrom[1]][computer_player.tileFrom[0]] = 1;

	//stag trace
	for(var i=0; i<prev_state[3].length; i++) {
		state[3].push(prev_state[3][i].map(x => Number((x * 0.9).toFixed(2))));
	}
	state[3][stag.tileFrom[1]][stag.tileFrom[0]] = 1;

	//allShrubs
	for(shrub of shrubs) {
		state[4][shrub.tile[1]][shrub.tile[0]] = 1;
	}
	prev_state = state.slice();	
	return state;
}

var moved = false;
var humanMove = null;
var computerMove = null;
var stagMove = null;

var handleKeyUp = function(e) {
	if(e.keyCode>=37 && e.keyCode<=40) {
		var currentFrameTime = Date.now();
		if((currentFrameTime-human_player.timeMoved>=human_player.delayMove)) {
			var validHumanAction = false;
			switch(e.keyCode) {
				case 37:
					if(human_player.tileFrom[0]>0 && gameMap[toIndex(human_player.tileFrom[0]-1, human_player.tileFrom[1])]==1) {
						human_player.tileTo[0]-= 1; //left
						validHumanAction = true;
						humanMove = e.keyCode;
					}
					break;
				case 38:
					if(human_player.tileFrom[1]>0 && gameMap[toIndex(human_player.tileFrom[0], human_player.tileFrom[1]-1)]==1) {
						human_player.tileTo[1]-= 1; //up
						validHumanAction = true;
						humanMove = e.keyCode;
					}
					break;
				case 39:
					if(human_player.tileFrom[0]<(mapW-1) && gameMap[toIndex(human_player.tileFrom[0]+1, human_player.tileFrom[1])]==1) {
						human_player.tileTo[0]+= 1; //right
						validHumanAction = true;
						humanMove = e.keyCode;
					}
					break;
				case 40:
					if(human_player.tileFrom[1]<(mapH-1) && gameMap[toIndex(human_player.tileFrom[0], human_player.tileFrom[1]+1)]==1) {
						human_player.tileTo[1]+= 1; //down
						validHumanAction = true;
						humanMove = e.keyCode;
					}
					break;
			}
			human_player.timeMoved = currentFrameTime;
			if (humanMove != null) {
				human_player.keysDown[humanMove] = true;
			}

			if(validHumanAction) {
				//blue player move
				var state = getBoardState();
				// TODO: must save without the borders
				saveToFirebase(state, humanMove);
				computerMove = computer_controller.move(state);
				computer_player.keysDown[computerMove] = true;

				// the stag either moves towards the nearest agent (default) or takes a random move.
				stagMove = stag_controller.move(state);
				stag.keysDown[stagMove] = true;
			}
		}
	}
}

window.onload = function()
{
	canvas = document.getElementById('game');
	ctx = canvas.getContext("2d");
	requestAnimationFrame(drawGame);
	ctx.font = "bold 10pt sans-serif";

	window.addEventListener("keyup", handleKeyUp);
};

function logics()
{
	var currentFrameTime = Date.now();
	var timeElapsed = currentFrameTime - lastFrameTime;
	
	var sec = Math.floor(Date.now()/1000);
	if(sec!=currentSecond)
	{
		currentSecond = sec;
		framesLastSecond = frameCount;
		frameCount = 1;
	}
	else { frameCount++; }

	if(!human_player.processMovement(currentFrameTime)) //move human player on board
	{
		moved = true;
		human_player.keysDown[humanMove] = false;

		if(human_player.tileFrom[0] != human_player.tileTo[0] || human_player.tileFrom[1] != human_player.tileTo[1])
		{ human_player.timeMoved = currentFrameTime; }
	}
	

	if(!computer_player.processMovement(currentFrameTime)) //move computer player on board
	{
		if(computer_player.keysDown[38] && computer_player.tileFrom[1]>0 && gameMap[toIndex(computer_player.tileFrom[0], computer_player.tileFrom[1]-1)]==1) { computer_player.tileTo[1]-= 1; }
		else if(computer_player.keysDown[40] && computer_player.tileFrom[1]<(mapH-1) && gameMap[toIndex(computer_player.tileFrom[0], computer_player.tileFrom[1]+1)]==1) { computer_player.tileTo[1]+= 1; }
		else if(computer_player.keysDown[37] && computer_player.tileFrom[0]>0 && gameMap[toIndex(computer_player.tileFrom[0]-1, computer_player.tileFrom[1])]==1) { computer_player.tileTo[0]-= 1; }
		else if(computer_player.keysDown[39] && computer_player.tileFrom[0]<(mapW-1) && gameMap[toIndex(computer_player.tileFrom[0]+1, computer_player.tileFrom[1])]==1) { computer_player.tileTo[0]+= 1; }
		computer_player.keysDown[computerMove] = false;

		if(computer_player.tileFrom[0]!=computer_player.tileTo[0] || computer_player.tileFrom[1]!=computer_player.tileTo[1])
		{ computer_player.timeMoved = currentFrameTime; }
	}

	if(!stag.processMovement(currentFrameTime)) //move stag on board
	{
		if(stag.keysDown[38] && stag.tileFrom[1]>0 && gameMap[toIndex(stag.tileFrom[0], stag.tileFrom[1]-1)]==1) { stag.tileTo[1]-= 1; }
		else if(stag.keysDown[40] && stag.tileFrom[1]<(mapH-1) && gameMap[toIndex(stag.tileFrom[0], stag.tileFrom[1]+1)]==1) { stag.tileTo[1]+= 1; }
		else if(stag.keysDown[37] && stag.tileFrom[0]>0 && gameMap[toIndex(stag.tileFrom[0]-1, stag.tileFrom[1])]==1) { stag.tileTo[0]-= 1; }
		else if(stag.keysDown[39] && stag.tileFrom[0]<(mapW-1) && gameMap[toIndex(stag.tileFrom[0]+1, stag.tileFrom[1])]==1) { stag.tileTo[0]+= 1; }
		stag.keysDown[stagMove] = false;

		if(stag.tileFrom[0]!=stag.tileTo[0] || stag.tileFrom[1]!=stag.tileTo[1])
		{
			//check for overlaps stag
			if(stag.tileTo[0] == human_player.tileTo[0] && stag.tileTo[1] == human_player.tileTo[1]) {
				if(stag.tileTo[0] == computer_player.tileTo[0] && stag.tileTo[1] == computer_player.tileTo[1]) {
					human_player.score = human_player.score + stag_reward;
					computer_player.score = computer_player.score + stag_reward;
				}
				else {
					human_player.score = human_player.score + mauling_punishment;		
				}
			}
			if(stag.tileTo[0] == computer_player.tileTo[0] && stag.tileTo[1] == computer_player.tileTo[1]) {
				if(stag.tileTo[0] != human_player.tileTo[0] || stag.tileTo[1] != human_player.tileTo[1]) {
					computer_player.score = computer_player.score + mauling_punishment;
				}
			}
			stag.timeMoved = currentFrameTime;
			counter_step++;
		}
	}

	//check for overlaps shrubs
	for(var i=0; i<shrubs.length; i++) {
		var overlaps = false; 
		var temp_shrub = shrubs[i];
		if(temp_shrub.tile[0] == human_player.tileFrom[0] && temp_shrub.tile[1] == human_player.tileFrom[1]) {
			overlaps = true;
			human_player.score = human_player.score + forage_reward;		
		}

		if(temp_shrub.tile[0] == computer_player.tileFrom[0] && temp_shrub.tile[1] == computer_player.tileFrom[1]) {
			overlaps = true;
			computer_player.score = computer_player.score + forage_reward;
		}

		if(overlaps) {
			if(i==0) {
				var index = i+1;
			}
			else{
				var index = i-1;
			}
			shrubs[i].set_tile(computer_player.tileFrom, human_player.tileFrom, stag.tileFrom, shrubs[index].tile);
		}
	}

	if(counter_step == steps_per_game && !finishFlag) {
		
		console.log('1) Computer score: '+ computer_player.score);
		console.log('2) Human score: '+ human_player.score);
		window.removeEventListener("keyup", handleKeyUp);
		
		finishFlag = true;
		finishGame(getBoardState(), humanMove); //sending the last state // TODO: Check this carefuly
	}
	lastFrameTime = currentFrameTime;
	return timeElapsed;
}

function drawGame()
{
	if(ctx==null) { return; }
	var timeElapsed = logics();

	// draw objects:
	for(var y = 0; y < mapH; ++y) // draw the board
	{
		for(var x = 0; x < mapW; ++x)
		{
			switch(gameMap[((y*mapW)+x)])
			{
				case 0:
					ctx.fillStyle = "#685b48"; // color: brown
					break;
				default:
					ctx.fillStyle = "#C4A484"; // color: light brown
			}

			ctx.fillRect( x*tileW, y*tileH, tileW, tileH);
		}
	}
	
	var borderWidth = 1;   
	var offset = borderWidth * 2;
	
	for(shrub of shrubs) {
		ctx.drawImage(shrub.iconImage, shrub.position[0] - borderWidth, shrub.position[1] -borderWidth, shrub.dimensions[0] + offset, shrub.dimensions[1] + offset);
	}
	ctx.drawImage(computer_player.iconImage, computer_player.position[0] - borderWidth, computer_player.position[1] -borderWidth, computer_player.dimensions[0] + offset, computer_player.dimensions[1] + offset);
	ctx.drawImage(human_player.iconImage, human_player.position[0] - borderWidth, human_player.position[1] -borderWidth, human_player.dimensions[0] + offset, human_player.dimensions[1] + offset);

	ctx.drawImage(stag.iconImage, stag.position[0] - borderWidth, stag.position[1] -borderWidth, stag.dimensions[0] + offset, stag.dimensions[1] + offset);

	ctx.fillStyle = "#0000ff"; // title color: blue
	ctx.fillText("Blue score: " + computer_player.score, 20, 20);
    ctx.fillText("Blue action: " + computer_player.codeToAction[computerMove], 20, 40);

	ctx.fillStyle = "#ff0000"; // title color: red
	ctx.fillText("Red score: " + human_player.score, 245, 20);
	ctx.fillText("Red action: " + human_player.codeToAction[humanMove], 245, 40);

	ctx.fillStyle = "#ffffff"; // title color: red
	ctx.fillText("Steps left: " + (steps_per_game - counter_step), 25, 320);
	ctx.fillText("Time: " + timeElapsed, 225, 320);
	
	requestAnimationFrame(drawGame);
}
